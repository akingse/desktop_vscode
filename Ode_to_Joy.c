//keil编程
// 单片机普通乐曲欢乐颂程序
#include <REG52.H>    
#include <INTRINS.H>    
sbit k1=P3^1;  //
sbit k2=P3^0;  // 定义按键K4
sbit k3=P3^3; 
sbit k4=P3^5; 
sbit led1=P2^0; //继电器
sbit led2=P2^1;
sbit led3=P2^2;
sbit led4=P2^3;
sbit led6=P2^5;
sbit led0=P2^6;
unsigned char n=0; 

/* 
1=D 4/4
D大调、四四拍
D大调是一个基于D(re)音的大调，英文为D major。由D、E、#F、G、A、B、#C组成;

1=C 4/4

1、出现在数字（音符）的上面，这是高音点，高音点的用法：有一个高音点这个音就高8度，有两个高音点就高2个八度。
2、出现在数字（音符）的下面，这是低音点，低音点的用法：有一个低音点这个音就低8度，有两个低音点就低2个八度。
3、出现在数字（音符）的旁边（右边 或说 后边）这个就是附点，占有它前面音符一半的时值。
 */

unsigned char code music_tab[] ={   //频率常数+节拍常数
// 标准
	0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
	0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
	0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
	0x03,0x00,0x03,0x09,0x02,0x00,0x02,0x00,
	
	0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
	0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
	0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
	0x02,0x00,0x02,0x09,0x01,0x00,0x01,0x00,

	0x02,0x00,0x02,0x00,0x03,0x09,0x01,0x00,
	0x02,0x00,0x03,0x00,0x04,0x00,0x03,0x09,0x01,0x00,
    0x02,0x00,0x03,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
	0x01,0x00,0x02,0x00,0x05,0x09,0x03,0x00,

	0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
	0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
	0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
	0x02,0x00,0x02,0x09,0x01,0x00,0x01,0x00,
// ---------------------------------------------原版
0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
0x02,0x00,0x02,0x00,0x02,0x00,

0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
0x01,0x00,0x01,0x00,0x02,0x00,0x03,0x00,
0x02,0x00,0x02,0x09,0x01,0x00,0x01,0x00,
0x02,0x00,0x02,0x00,0x03,0x00,0x09,0x01,0x00,0x08,0x00,
0x02,0x00,0x03,0x00,0x04,0x00,0x03,0x09,0x01,0x00,

0x08,0x00,
0x02,0x00,0x03,0x00,0x04,0x00,0x03,0x00,0x02,0x09,
0x01,0x00,0x08,0x00,0x02,0x09,0x01,0x00,0x08,0x00,

0x03,0x00,0x03,0x00,0x04,0x00,0x05,0x00,
0x05,0x00,0x04,0x00,0x03,0x00,0x02,0x09,0x01,0x00,
0x08,0x00,0x02,0x00,0x03,0x00,0x02,0x00,
0x02,0x09,0x01,0x00,0x01,0x00,

};   
//   定时器0的中断函数，定时器0的中断号是1，所以后面是interrupt 1
void int0()  interrupt 1    //采用中断0 控制节拍    
{  TH0=0xd8;   
   TL0=0xef;   
   n--;   
}   /* 为 T0 计数器赋初值，（高位）TH0=0xd8，（低位）TL0=0xf0
换成 10 进制是：55536，那么 65536-55536=10000,表明 T0 计数器 计数 10000 个机器周期后溢出。
如果使用 12M 晶振，那么计数 10000 个机器周期使用 10ms，可以作为定时用。 */

void keypi(){
	unsigned char p;      
	unsigned char i;
	if(k1==0){ 	 //再次判断按键是否按下
		led6=1;  
		while(1){
			p=music_tab[i];   
			if (p==0x08){						n=0x20;			}  
			else if (p==0x01){			led1=0; n=0x20;			}  
			else if (p==0x02){			led1=0; n=0x20;			}   //控制手指
			else if (p==0x03){			led2=0; n=0x20;			}
			else if (p==0x04){ 			led3=0; n=0x20;			}      
			else if (p==0x05){			led4=0; n=0x20;			}  
			else if (p==0x09){			led6=0; n=0x10;			}   //移动信号
			else if (p==0x00){	 		    	n=0x15;			}   //停顿
			i=i+1;

			TR0=1; //TR0 用于启动、停止定时器的计数
			while(n!=0); 	//仅当 n=0 继续往下执行
			TR0=0; 
			if(k3==0||led6==0) { //锁定态
				while(1){
					led0=0;//led=1;led1=1;led2=1;led3=1;led4=1;
					if(k1==0){  //等待移动完毕
						led0=1;
						led6=1;
						break;
					}
				}
			}
		}
	}
}
	 
//		while(!k1);	 //检测按键是否松开
void main(){  
	unsigned char i=0;
	TMOD&=0x0f;   //清除低位，即： bxxxx0000
	TMOD|=0x01;   //置最后一位1,即 bxxxx0000 | b00000001 = bxxxx0001
	TH0=0xd8;
	TL0=0xef;   
	IE=0x82;   //IE是中断允许寄存器，其值为82时，二进制为1000 0010，IE.7位为1表示CPU开放中断，IE.1位也为1，表示允许定时器T0溢出中断
	keypi();  //按键处理函数	
}

//使用按键作为输入，小灯作为输出，实际模拟这个过程

/*
通过继电器传送信号，单片机收到信号输入，解除锁定同时执行按键程序，单片机手指动作信号被发送给继电器，控制24v电压驱动手指开始动作，
手指动作之后，直线电机需要继续运动，则通过IO口发送锁定信号，同样通过继电器进行转换，单片机收到信号，手指立即复位，直线电机继续运动，通过此循环不断往复，来演奏音乐。

启用一位elmo输入口，此方案下单片机作为主导，控制elmo驱动器动作与反馈，首先单片机控制机械手动作，需要移动时单片机发送信号给驱动器，
驱动器驱动直线电机同时反馈锁定信号，单片机锁定手指复位，移动后驱动器解锁单片机，单片机解锁手指
*/
